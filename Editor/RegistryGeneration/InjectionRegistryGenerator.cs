using System;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine;
using YanickSenn.Utils.RegistryGeneration;

namespace YanickSenn.Utils.Editor.RegistryGeneration {

    public class InjectionRegistryGenerator : AssetPostprocessor {

        private static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths) {
            if (importedAssets.Any(IsScriptableObject) || deletedAssets.Any(IsScriptableObject) || movedAssets.Any(IsScriptableObject)) {
                Generate();
            }
        }

        private static bool IsScriptableObject(string path) {
            return path.EndsWith(".asset", StringComparison.OrdinalIgnoreCase);
        }

        [MenuItem("Tools/YanickSenn/Utils/Force Generate Injection Registries")]
        public static void Generate() {
            if (UtilsSettings.instance.RegistryGenerationSettings.disabled) {
                return;
            }

            var targetTypes = TypeCache.GetTypesWithAttribute<GenerateInjectionRegistryAttribute>();
            var outputDir = "Assets/Generated/Registries";

            if (!Directory.Exists(outputDir)) {
                Directory.CreateDirectory(outputDir);
            }

            foreach (var type in targetTypes) {
                var attr = System.Reflection.CustomAttributeExtensions.GetCustomAttribute<GenerateInjectionRegistryAttribute>(type);
                if (attr != null && attr.Generate) {
                    GenerateRegistryForType(type, outputDir);
                }
            }
            
            AssetDatabase.Refresh();
        }

        private static void GenerateRegistryForType(Type type, string outputDir) {
            var assets = InjectionUtils.FindAssetsByType(type);
            var className = $"{type.Name}Registry";
            var filePath = Path.Combine(outputDir, $"{className}.cs");

            var sb = new StringBuilder();
            sb.AppendLine("using UnityEngine;");
            sb.AppendLine("using VContainer;");
            sb.AppendLine("using VContainer.Unity;");
            sb.AppendLine();
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("//     This code was generated by YanickSenn.Utils.Editor.Injection.InjectionRegistryGenerator.");
            sb.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
            sb.AppendLine("//     the code is regenerated.");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine();
            sb.AppendLine($"public class {className} : YanickSenn.Utils.ScriptableObjectInstaller {{");
            sb.AppendLine();
            sb.AppendLine("    public enum Keys {");
            foreach (var asset in assets) {
                var fieldName = InjectionUtils.SanitizeName(asset.name);
                sb.AppendLine($"        {fieldName},");
            }
            sb.AppendLine("    }");
            sb.AppendLine();
            
            foreach (var asset in assets) {
                var fieldName = InjectionUtils.SanitizeName(asset.name);
                sb.AppendLine($"    public {type.FullName} {fieldName};");
            }

            sb.AppendLine();
            sb.AppendLine("    public override void Install(IContainerBuilder builder) {");
            
            foreach (var asset in assets) {
                var fieldName = InjectionUtils.SanitizeName(asset.name);
                sb.AppendLine($"        if ({fieldName} != null) {{");
                sb.AppendLine($"            builder.RegisterInstance({fieldName}).Keyed(Keys.{fieldName});");
                sb.AppendLine($"        }}");
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            var content = sb.ToString();
            if (!File.Exists(filePath) || File.ReadAllText(filePath) != content) {
                File.WriteAllText(filePath, content);
                Debug.Log($"Generated registry: {filePath}");
            }
        }
    }
}
